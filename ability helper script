local CollectionService = game:GetService("CollectionService") 

local module = {}

-- Weapon table with all weapon information
module.Weapons = {
	Punch = {
		Damage = 25,
		Range = 10,
		Cooldown = 1,
	},
}

function module.AddWeapon(plr, weaponName)
	-- Check if the weapon exists in the table
	local weaponData = module.Weapons[weaponName]
	if not weaponData then
		warn("Weapon '" .. weaponName .. "' not found!")
		return
	end

	-- Find or create the Weapons folder in the player
	local weaponsFolder = plr:FindFirstChild("Weapons")
	if not weaponsFolder then
		weaponsFolder = Instance.new("Folder")
		weaponsFolder.Name = "Weapons"
		weaponsFolder.Parent = plr
	end

	-- Create a folder for this specific weapon
	local weaponFolder = Instance.new("Folder")
	weaponFolder.Name = weaponName
	weaponFolder.Parent = weaponsFolder

	-- Create Value objects for each key in the weapon data
	for key, value in pairs(weaponData) do
		local valueObj

		-- Create the appropriate Value type based on the data type
		if type(value) == "number" then
			if value % 1 == 0 then
				valueObj = Instance.new("IntValue")
			else
				valueObj = Instance.new("NumberValue")
			end
		elseif type(value) == "string" then
			valueObj = Instance.new("StringValue")
		elseif type(value) == "boolean" then
			valueObj = Instance.new("BoolValue")
		end

		if valueObj then
			valueObj.Name = key
			valueObj.Value = value
			valueObj.Parent = weaponFolder
		end
	end
end

function module.playSoundClone(parent, originalSound)
	if not parent or not originalSound then
		warn("playSoundClone: parent and originalSound parameters are required")
		return
	end

	if not originalSound:IsA("Sound") then
		warn("playSoundClone: originalSound must be a Sound object")
		return
	end

	local soundClone = originalSound:Clone()
	soundClone.Parent = parent
	soundClone:Play()
	local connection
	connection = soundClone.Ended:Connect(function()
		connection:Disconnect()
		soundClone:Destroy()
	end)
	return soundClone
end

function module.KnockBack(Humanoid, Direction, Strength)
	local targetRoot = Humanoid.Parent:FindFirstChild("HumanoidRootPart")
	if targetRoot then
		local upwardDirection = Direction + Vector3.new(0, 0.2, 0)
		targetRoot.Velocity = upwardDirection * Strength
	end
end

function module.GetHumanoidInHitBox(character, head, direction, range, width, height)
	-- Calculate hitbox position (centered in front of player in the given direction)
	local hitboxPos = head.Position + (direction * (range / 2))
	
	-- Create OverlapParams
	local overlapParams = OverlapParams.new()
	overlapParams.FilterDescendantsInstances = {character}
	overlapParams.FilterType = Enum.RaycastFilterType.Exclude
	
	-- Create a CFrame oriented in the direction
	local hitboxCFrame = CFrame.lookAt(hitboxPos, hitboxPos + direction)
	
	-- Use GetPartBoundsInBox which properly handles rotation
	local parts = workspace:GetPartBoundsInBox(
		hitboxCFrame,
		Vector3.new(width, height, range),
		overlapParams
	)
	
	local playersInRange = {}
	
	-- Check for humanoids
	for _, part in pairs(parts) do
		local model = part:FindFirstAncestorOfClass("Model")
		if model then
			local foundHumanoid = model:FindFirstChild("Humanoid")
			if foundHumanoid and foundHumanoid.Parent ~= character then
				if not table.find(playersInRange, foundHumanoid) then
					table.insert(playersInRange, foundHumanoid)
				end
			end
		end
	end
	
	return playersInRange
end

function module.GiveDamage(Plr, humanoid, Damage)
	if humanoid and humanoid.Health > 0 then
		local previousHealth = humanoid.Health
		humanoid:TakeDamage(Damage)
		if humanoid.Health <= 0 and previousHealth > 0 then
			local isNPC = CollectionService:HasTag(humanoid.Parent, "NPC")
			if isNPC then
				task.spawn(function()
					task.wait(5)
					if humanoid.Parent then
						humanoid.Parent:Destroy()
					end
				end)
			end
		end
	end
end

function module.GetClosestEnemy(Plr)
	local Character = Plr.Character
	local Root = Character:FindFirstChild("HumanoidRootPart")
	local Humanoid = Character:FindFirstChild("Humanoid")
	if not Root or not Humanoid then return nil end

	local closestEnemy = nil
	local closestDistance = math.huge

	local CollectionService = game:GetService("CollectionService")
	local NPCs = CollectionService:GetTagged("NPC")

	-- Create a table to store NPCs sorted by distance
	local npcDistances = {}

	for _, npc in ipairs(NPCs) do
		if npc:IsA("Model") then
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			local npcHumanoid = npc:FindFirstChild("Humanoid")

			if npcRoot and npcHumanoid and npcHumanoid.Health > 0 then
				local distance = (Root.Position - npcRoot.Position).Magnitude
				table.insert(npcDistances, {npc = npc, distance = distance, root = npcRoot})
			end
		end
	end

	-- Sort NPCs by distance
	table.sort(npcDistances, function(a, b)
		return a.distance < b.distance
	end)

	-- Check each NPC in order of distance for line of sight
	for _, data in ipairs(npcDistances) do
		local direction = (data.root.Position - Root.Position).Unit
		local distance = data.distance

		local raycastParams = RaycastParams.new()
		raycastParams.FilterDescendantsInstances = {Character, data.npc}
		raycastParams.FilterType = Enum.RaycastFilterType.Exclude

		local raycastResult = workspace:Raycast(Root.Position, direction * distance, raycastParams)

		-- If raycast hits nothing, we have line of sight
		if not raycastResult then
			closestEnemy = data.npc
			break
		end
	end

	return closestEnemy
end

return module
